@page "/node-detail/{NodeId}"
@using Acme.Greenhouse.Blazor.Components
@using Acme.Greenhouse.Blazor.ViewModels
@using Acme.Greenhouse.Devices
@using Acme.Greenhouse.Extensions
@using Acme.Greenhouse.Nodes
@using Acme.Greenhouse.SensorData
@using Acme.Greenhouse.Sensors
@using Microsoft.Extensions.Logging
@using Microsoft.FluentUI.AspNetCore.Components.DesignTokens
@using MQTTnet.Client
@using MQTTnet.Extensions.ManagedClient
@using Orientation = Microsoft.FluentUI.AspNetCore.Components.Orientation
@using System.Text.RegularExpressions
@using System.Text
@using MQTTnet
@inject INodeService NodeService
@inject ISensorService SensorService
@inject IDeviceService DeviceService
@inject ISensorDataService SensorDataService
@attribute [StreamRendering(true)]
@attribute [Authorize]
@rendermode RenderMode.InteractiveServer
@inject IToastService ToastService
@inject IManagedMqttClient MqttService
@inject FillColor FillColor
@inject BaseLayerLuminance BaseLayerLuminance
@inherits GreenhouseComponentBase

<div class="container">
    @if (!Loaded)
    {
        <div class="text-center h2">Loading...</div>
    }
    else
    {
        @if (Node is null)
        {
            <div class="text-center h2">404 NotFound</div>
            return;
        }

        <FluentToolbar id="toolbar-fluent-components" @ref="Toolbar" Style="width: 100%">
            <FluentSelect TOption="string" ValueChanged="OptionChanged">
                <FluentOption Value="Item 1" Selected="true">1 hour ago</FluentOption>
                <FluentOption Value="Item 2">2 hour ago</FluentOption>
                <FluentOption Value="Item 3">6 hour ago</FluentOption>
                <FluentOption Value="Item 4">12 hour ago</FluentOption>
                <FluentOption Value="Item 5">1 day ago</FluentOption>
            </FluentSelect>
            <FluentCheckbox @bind-Value="@_isCustomTime">Custom</FluentCheckbox>
            @if (_isCustomTime)
            {
                <FluentDatePicker Label="From" Value="FromDate" ValueChanged="@(e => FromDate = e.GetValueOrDefault())"/>
                <FluentDatePicker Label="To" Value="ToDate" ValueChanged="@(e => ToDate = e.GetValueOrDefault())"/>
                <FluentButton Appearance="Appearance.Accent" OnClick="ApplyCustomTime">Apply</FluentButton>
            }
            else
            {
                <FluentCheckbox ValueChanged="RealtimeCheckChanged" Disabled="_realtimeDisabled">Realtime</FluentCheckbox>
            }
            <FluentButton Appearance="Appearance.Accent" IconStart="@(new Icons.Regular.Size20.ArrowExport())" OnClick="ExportToExcel" slot="end">
                Export
                <FluentBadge slot="end">Preview</FluentBadge>
            </FluentButton>
        </FluentToolbar>
        <div class="text-center h2 mb-4">@Node.Name</div>
        @if (_isCustomTime)
        {
            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="h4">
                        <span>From</span>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="h4">
                        <span>To</span>
                    </div>
                </div>
            </div>
        }

        <div>
            @if (NodeViewModel != null)
            {
                if (NodeViewModel.Sensors != null)
                {
                    foreach (var sensor in NodeViewModel.Sensors)
                    {
                        <SensorStatComponent Sensor="sensor"/>
                        <SfGrid ID="Grid" class="invisible" @ref="Grid" DataSource="@sensor.Data" AllowPaging="true" AllowExcelExport="true" AllowPdfExport="true">
                            <GridColumns>
                                <GridColumn Field=@nameof(SensorDataDto.SensorId) HeaderText="ID" TextAlign="TextAlign.Right" Width="120"></GridColumn>
                                <GridColumn Field=@nameof(SensorDataDto.CreationTime) HeaderText="Time" Width="150"></GridColumn>
                                <GridColumn Field=@nameof(SensorDataDto.Value) HeaderText="Value" Format="N1" TextAlign="TextAlign.Right" Width="120"></GridColumn>
                            </GridColumns>
                        </SfGrid>
                    }
                }
            }
            else
            {
                <div>No data</div>
            }

        </div>
    }
</div>

@code {
    [Parameter] public string NodeId { get; set; } = default!;
    FluentToolbar? Toolbar;
    private bool _realtime = false;
    private bool _realtimeDisabled = false;
    private DateTime _fromDate = DateTime.Now.AddDays(-1);

    private DateTime FromDate
    {
        get => _fromDate;
        set
        {
            _fromDate = value;
            GetData().Wait();
        }
    }

    private DateTime _fromTime = DateTime.Now;

    private DateTime FromTime
    {
        get => _fromTime;
        set
        {
            _fromTime = value;
            GetData().Wait();
        }
    }

    private DateTime _toDate = DateTime.Now;

    private DateTime ToDate
    {
        get => _toDate;
        set
        {
            _toDate = value;
            GetData().Wait();
        }
    }

    private DateTime _toTime = DateTime.Now;

    private DateTime ToTime
    {
        get => _toTime;
        set
        {
            _toTime = value;
            GetData().Wait();
        }
    }

    public NodeDto? Node { get; set; }
    public NodeViewModel? NodeViewModel { get; set; }
    public bool Loaded { get; set; }
    private string _selectedOption;
    private bool _isCustomTime;
    private SfGrid<SensorDataDto> Grid = new();

    protected override async Task OnInitializedAsync()
    {
        if (!int.TryParse(NodeId, out var nodeId))
            return;
        try
        {
            await InvokeAsync(() => { Loaded = false; });
            Node = await NodeService.GetAsync(nodeId);
            await GetData(DateTime.Now.AddHours(-1), DateTime.Now);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex.Message);
        }
        finally
        {
            await InvokeAsync(() =>
            {
                Loaded = true;
                StateHasChanged();
            });
        }
    }

    private async Task GetData(DateTime? from = null, DateTime? to = null)
    {
        try
        {
            await InvokeAsync(() =>
            {
                Loaded = false;
                StateHasChanged();
            });
            var now = DateTime.Now;
            if (from is null || to is null)
            {
                from = new DateTime(FromDate.Year, FromDate.Month, FromDate.Day, 0, 0, 0);
                to = new DateTime(ToDate.Year, ToDate.Month, ToDate.Day, 0, 0, 0);
            }

            NodeViewModel = new NodeViewModel()
            {
                Node = Node!,
                Sensors = (await SensorService.GetByNodeId(Node!.Id)).Select(x => new SensorViewModel()
                {
                    Sensor = x,
                    Data = SensorDataService.GetByDate(x.Id, from.Value, to.Value).Result
                }).ToList(),
                Devices = (await DeviceService.GetByNodeId(Node.Id)).Select(x => new DeviceViewModel()
                {
                    Device = x
                }).ToList()
            };
            await InvokeAsync(() =>
            {
                Loaded = true;
                StateHasChanged();
            });
        }
        catch (Exception e)
        {
            ToastService.ShowError(title: "Error", timeout: 2000);
            Logger.LogError(e.Message);
        }
    }

    private async Task ApplyCustomTime()
    {
        try
        {
            var from = new DateTime(FromDate.Year, FromDate.Month, FromDate.Day, 0, 0, 0);
            var to = new DateTime(ToDate.Year, ToDate.Month, ToDate.Day, 0, 0, 0);
            await GetData(from, to);
        }
        catch (Exception e)
        {
            ToastService.ShowError(title: "Error", timeout: 2000);
            Logger.LogError(e.Message);
        }
    }

    private async Task BtnRefreshClick()
    {
        await GetData();
    }


    private async Task OptionChanged(string? arg)
    {
        if (arg is null)
            return;
        _selectedOption = arg;
        _realtimeDisabled = arg != "Item 1";
        if (_realtimeDisabled)
            _realtime = false;
        var now = DateTime.Now;
        switch (arg)
        {
            case "Item 1":
                await GetData(now.AddHours(-1), now);
                break;
            case "Item 2":
                await GetData(now.AddHours(-2), now);
                break;
            case "Item 3":
                await GetData(now.AddHours(-6), now);
                break;
            case "Item 4":
                await GetData(now.AddHours(-12), now);
                break;
            case "Item 5":
                await GetData(now.AddHours(-24), now);
                break;
        }
    }

    private async Task ExportToExcel()
    {
        ToastService.ShowDownload(title: "Downloading", timeout: 2000);
        if (NodeViewModel == null || NodeViewModel.Sensors == null)
        {
            return;
        }

        foreach (var sensor in NodeViewModel.Sensors)
        {
            await this.Grid.ExportToExcelAsync();
        }
    }

    private Task RealtimeCheckChanged(bool val)
    {
        if (val)
        {
            MqttService.ApplicationMessageReceivedAsync += ApplicationMessageReceived;
        }
        else
        {
            MqttService.ApplicationMessageReceivedAsync -= ApplicationMessageReceived;
        }

        return Task.CompletedTask;
    }

    private async Task ApplicationMessageReceived(MqttApplicationMessageReceivedEventArgs e)
    {
        try
        {
            var topic = e.ApplicationMessage.Topic;
            Regex regex = new(@"sensors\/([a-f,0-9,-]+)\/");

            var match = regex.Match(topic);
            if (match.Success)
            {
                var sensorId = int.Parse(match.Groups[1].Value);
                if (NodeViewModel != null && NodeViewModel.Sensors != null && NodeViewModel.Sensors.Any(s => s.Sensor.Id == sensorId))
                {
                    var now = DateTime.Now;
                    await GetData(now.AddHours(-1), now);
                    var sensorVm = NodeViewModel.Sensors.Single(s => s.Sensor.Id == sensorId);
                    var value = double.Parse(e.ApplicationMessage.ConvertPayloadToString());
                    sensorVm.Data.Add(new SensorDataDto() { SensorId = sensorId, Value = value, CreationTime = DateTime.Now });
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (Exception ex)
        {
            ToastService.ShowError(title: "Error", timeout: 2000);
            Logger.LogError(ex.Message);
        }
    }

}